{
  "name": "storablejs",
  "version": "0.0.20",
  "description": "A javascript datastore built using RxJS Observables",
  "main": "index.js",
  "scripts": {
    "compile": "babel -i __tests__ -d ./ src/",
    "prepublish": "npm run compile && npm test",
    "test": "jest"
  },
  "jest": {
    "rootDir": "./src",
    "scriptPreprocessor": "../node_modules/babel-jest",
    "testFileExtensions": [
      "es6",
      "js"
    ],
    "moduleFileExtensions": [
      "js",
      "json",
      "es6"
    ]
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/nramadas/Storable.git"
  },
  "keywords": [
    "datastore",
    "observable",
    "rx",
    "rxjs"
  ],
  "author": {
    "name": "Niranjan Ramadas",
    "email": "nrbramadas@gmail.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/nramadas/Storable/issues"
  },
  "homepage": "https://github.com/nramadas/Storable#readme",
  "devDependencies": {
    "babel": "^5.8.23",
    "babel-jest": "^5.3.0",
    "jest-cli": "^0.5.0"
  },
  "peerDependencies": {
    "rx": ""
  },
  "dependencies": {
    "lodash": "^3.10.1"
  },
  "readme": "# Storable\nStorable is an Observable based data store. The store is queried using keyPaths with each query returning an Observable.\n\nStorable also comes with a way to step through store state as it changed, allowing the developer to pause state, rewind and fast forward, and even drop any queued state that accumulated when the state was paused.\n\n## To Install\n```\nnpm install storeablejs\n```\n\n## Usage\n```es6\nimport Store from \"storablejs/Store\";\n\nconst store = new Store();\n```\n\n## Querying for data\n#### Single key path\n```es6\nstore.query(\"foo\", \"bar\").forEach((data) => {\n    // data:\n    // {\n    //     bar: <value>\n    // }\n});\n```\n#### Multiple key paths\n```es6\nstore.query(\n    [\"foo\", \"bar\"],\n    [\"baz\", \"hum\"]\n).forEach((data) => {\n    // data:\n    // {\n    //     bar: <value>,\n    //     hum: <value>\n    // }\n});\n```\n#### Aliasing key paths\n```es6\nstore.query(\n    [\"foo\", \"bar\", {alias: \"bar1\"}],\n    [\"baz\", \"bar\", {alias: \"bar2\"}]\n).forEach((data) => {\n    // data:\n    // {\n    //     bar1: <value>,\n    //     bar2: <value>\n    // }\n})\n```\n#### Seeding data\n```es6\nconst seedFn = (writeResult) => {\n    writeResult(\"foo\");\n};\n\nstore.query(\"foo\", \"bar\", {ensure: seedFn});\n```\n#### Seeding data asynchronously\nUseful if the seed data comes from the server\n```es6\nconst fetchData = (writeResult) => {\n    performServerCall().then(writeResult);\n}\n\nstore.query(\"foo\", \"bar\", {ensure: fetchData});\n```\n## Writing Data\n```es6\nstore.emit({\n    foo: {\n        bar: \"baz\"\n    }\n});\n// NOTE: data can be deeply nested, even if the keys don't yet exist in the\n// Inventory. The keys are created as the data is written.\n```\n\n## Using the Manager to step through state\n#### Setup\n```es6\nimport Inventory from \"storablejs/Inventory\";\nimport Manager   from \"storablejs/Manager\";\nimport Store     from \"storablejs/Store\";\n\nconst inventory = new Inventory();\nconst manager = new Manager(inventory);\nconst store = new Store(inventory, manager);\n```\n\n#### Time-travelling through Store state\n```es6\nmanager.pause();            // Prevent new Store emmisions from changing state.\n                            // New state emmissions from the Store are queued.\n\nmanager.resume();           // Allows the Store to function as usual. Also, any\n                            // queued state will be played.\n\nmanager.rewind(n);          // Go back n steps if possible. This will also pause\n                            // the manager.\n\nmanager.fastForward(n);     // Go forward n steps if possible. This will also\n                            // pause the manager.\n\nmanager.goto(n);            // Go to a specific state, where 'n' represents the\n                            // index of that store state relative to the first\n                            // state.\n\nmanager.commit();           // Removes any queued state.\n```\n\n#### Viewing the contents of the Manager\n```es6\nmanager.updates.forEach((updates) => {\n    const {\n        currentLedgerIndex, // The index of current state.\n        isTimeTravelling,   // Indicates of the manager is paused or not.\n        transactions,       // An array of all emitted states.\n    } = updates;\n};)\n```\n\n## Grouping Store methods\nIt is often useful to group methods that deal with similar slices of data together into a single module. As a convenience, a `Clerk` can be used to help combine multiple modules together.\n\n```es6\nimport Store from \"storablejs/Store\";\nimport Clerk from \"storablejs/Clerk\";\n\nimport storeMethods1 from \"./storeMethods1\";\nimport storeMethods2 from \"./storeMethods2\";\n\nconst store = new Store();\nconst clerk = new Clerk(store, {\n    ...storeMethods1,\n    ...storeMethods2,\n});\n\nclerk.someMethod();\n```\n\nThe `Clerk` itself has the ability to emit on the `Store`. When creating a module for the `Clerk` to consume, assume that a method called `emit` exists as a property of the module.\n\nThe module itself should just export a dictionary of methods. Ex:\n\n```es6\n// storeMethods1.js\n\nexport default {\n    someMethod() {\n        this.emit({foo: \"bar\"});\n    },\n\n    someOtherMethod() {\n        this.emit(await doSomethingAsyc());\n    },\n}\n```\n",
  "readmeFilename": "README.md",
  "gitHead": "4cf7886887652085ef3251136faf26b289ff606a",
  "_id": "storablejs@0.0.20",
  "_shasum": "b2599f65f694e43ecd3f7c1e05689df246ca04d3",
  "_from": "storablejs@*"
}
